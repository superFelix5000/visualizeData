import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
let NgxCsvParser = class NgxCsvParser {
    constructor() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
    }
    parse(csvFile, config) {
        config = Object.assign(Object.assign({}, this.defaultCSVParserConfig), config);
        const ngxCSVParserObserver = new Observable((observer) => {
            try {
                let csvRecords = null;
                if (this.isCSVFile(csvFile)) {
                    const reader = new FileReader();
                    reader.readAsText(csvFile);
                    reader.onload = () => {
                        const csvData = reader.result;
                        const csvRecordsArray = this.csvStringToArray(csvData.trim(), config.delimiter);
                        const headersRow = this.getHeaderArray(csvRecordsArray);
                        csvRecords = this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords);
                        observer.complete();
                    };
                    reader.onerror = () => {
                        this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    }
    csvStringToArray(csvDataString, delimiter) {
        const regexPattern = new RegExp((`(\\${delimiter}|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\${delimiter}\"\\r\\n]*))`), "gi");
        let matchedPatternArray = regexPattern.exec(csvDataString);
        const resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            const cleanValue = matchedPatternArray[2] ?
                matchedPatternArray[2].replace(new RegExp("[\\\\\"](.)", "g"), '$1') : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    }
    getDataRecordsArrayFromCSVFile(csvRecordsArray, headerLength, config) {
        const dataArr = [];
        const headersArray = csvRecordsArray[0];
        const startingRowToParseData = config.header ? 1 : 0;
        for (let i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            const data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                const csvRecord = {};
                for (let j = 0; j < data.length; j++) {
                    if ((data[j] === undefined) || (data[j] === null)) {
                        csvRecord[headersArray[j]] = "";
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    }
    isCSVFile(file) {
        return file.name.toLowerCase().endsWith('.csv');
    }
    getHeaderArray(csvRecordsArr) {
        const headers = csvRecordsArr[0];
        const headerArray = [];
        for (const header of headers) {
            headerArray.push(header);
        }
        return headerArray;
    }
    notCSVFileErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    }
    unknownCSVParserErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    }
    badCSVDataFormatErrorHandler(observer) {
        const ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    }
    errorBuilder(type, message, code) {
        const ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    }
};
NgxCsvParser.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
NgxCsvParser = __decorate([
    Injectable({
        providedIn: 'root'
    })
], NgxCsvParser);
export { NgxCsvParser };
class CSVParserConfig {
    constructor() { }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jc3YtcGFyc2VyLyIsInNvdXJjZXMiOlsibGliL25neC1jc3YtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7QUFLNUUsSUFBYSxZQUFZLEdBQXpCLE1BQWEsWUFBWTtJQUF6QjtRQUVZLDJCQUFzQixHQUFHO1lBQzdCLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7U0FDakIsQ0FBQztLQWdJTDtJQTlIRyxLQUFLLENBQUMsT0FBYSxFQUFFLE1BQXVCO1FBRXhDLE1BQU0sbUNBQ0MsSUFBSSxDQUFDLHNCQUFzQixHQUMzQixNQUFNLENBQ1osQ0FBQztRQUVGLE1BQU0sb0JBQW9CLEdBQUcsSUFBSSxVQUFVLENBQUMsQ0FBQyxRQUFrRCxFQUFFLEVBQUU7WUFDL0YsSUFBSTtnQkFDQSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBRXRCLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFFekIsTUFBTSxNQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FBQztvQkFDaEMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFM0IsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEVBQUU7d0JBQ2pCLE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUM7d0JBQzlCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBRSxPQUFrQixDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQzt3QkFFNUYsTUFBTSxVQUFV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QUUsMEVBQTBFLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDeEgsUUFBUSxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRCw0QkFBNEIsQ0FBQyxRQUF1QjtRQUNoRCxNQUFNLGlCQUFpQixHQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLDJCQUEyQixFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdFLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsWUFBWSxDQUFDLElBQVksRUFBRSxPQUFZLEVBQUUsSUFBUztRQUM5QyxNQUFNLGlCQUFpQixHQUFzQixJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDckUsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3BDLGlCQUFpQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDOUIsT0FBTyxpQkFBaUIsQ0FBQztJQUM3QixDQUFDO0NBQ0osQ0FBQTs7QUFySVksWUFBWTtJQUh4QixVQUFVLENBQUM7UUFDUixVQUFVLEVBQUUsTUFBTTtLQUNyQixDQUFDO0dBQ1csWUFBWSxDQXFJeEI7U0FySVksWUFBWTtBQXVJekIsTUFBTSxlQUFlO0lBSWpCLGdCQUFnQixDQUFDO0NBQ3BCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZlciB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBOZ3hDU1ZQYXJzZXJFcnJvciB9IGZyb20gJy4vX21vZGVsL25neC1jc3YtcGFyc2VyLWVycm9yLmludGVyZmFjZSc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5neENzdlBhcnNlciB7XHJcblxyXG4gICAgcHJpdmF0ZSBkZWZhdWx0Q1NWUGFyc2VyQ29uZmlnID0ge1xyXG4gICAgICAgIGhlYWRlcjogdHJ1ZSxcclxuICAgICAgICBkZWxpbWl0ZXI6ICcsJ1xyXG4gICAgfTtcclxuXHJcbiAgICBwYXJzZShjc3ZGaWxlOiBGaWxlLCBjb25maWc6IENTVlBhcnNlckNvbmZpZyk6IE9ic2VydmFibGU8QXJyYXk8YW55PiB8IE5neENTVlBhcnNlckVycm9yPiB7XHJcblxyXG4gICAgICAgIGNvbmZpZyA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0Q1NWUGFyc2VyQ29uZmlnLFxyXG4gICAgICAgICAgICAuLi5jb25maWdcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBuZ3hDU1ZQYXJzZXJPYnNlcnZlciA9IG5ldyBPYnNlcnZhYmxlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXJyYXk8YW55PiB8IE5neENTVlBhcnNlckVycm9yPikgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGNzdlJlY29yZHMgPSBudWxsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ1NWRmlsZShjc3ZGaWxlKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGNzdkZpbGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3ZEYXRhID0gcmVhZGVyLnJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3N2UmVjb3Jkc0FycmF5ID0gdGhpcy5jc3ZTdHJpbmdUb0FycmF5KChjc3ZEYXRhIGFzIHN0cmluZykudHJpbSgpLCBjb25maWcuZGVsaW1pdGVyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNSb3cgPSB0aGlzLmdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnJheSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRzID0gdGhpcy5nZXREYXRhUmVjb3Jkc0FycmF5RnJvbUNTVkZpbGUoY3N2UmVjb3Jkc0FycmF5LCBoZWFkZXJzUm93Lmxlbmd0aCwgY29uZmlnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoY3N2UmVjb3Jkcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFkQ1NWRGF0YUZvcm1hdEVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90Q1NWRmlsZUVycm9ySGFuZGxlcihvYnNlcnZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmtub3duQ1NWUGFyc2VyRXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gbmd4Q1NWUGFyc2VyT2JzZXJ2ZXI7XHJcbiAgICB9XHJcblxyXG4gICAgY3N2U3RyaW5nVG9BcnJheShjc3ZEYXRhU3RyaW5nOiBzdHJpbmcsIGRlbGltaXRlcjogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmVnZXhQYXR0ZXJuID0gbmV3IFJlZ0V4cCgoYChcXFxcJHtkZWxpbWl0ZXJ9fFxcXFxyP1xcXFxufFxcXFxyfF4pKD86XFxcIigoPzpcXFxcXFxcXC58XFxcIlxcXCJ8W15cXFxcXFxcXFxcXCJdKSopXFxcInwoW15cXFxcJHtkZWxpbWl0ZXJ9XFxcIlxcXFxyXFxcXG5dKikpYCksIFwiZ2lcIilcclxuICAgICAgICBsZXQgbWF0Y2hlZFBhdHRlcm5BcnJheSA9IHJlZ2V4UGF0dGVybi5leGVjKGNzdkRhdGFTdHJpbmcpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdENTViA9IFtbXV07XHJcbiAgICAgICAgd2hpbGUgKG1hdGNoZWRQYXR0ZXJuQXJyYXkpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0ubGVuZ3RoICYmIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMV0gIT09IGRlbGltaXRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Q1NWLnB1c2goW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuVmFsdWUgPSBtYXRjaGVkUGF0dGVybkFycmF5WzJdID9cclxuICAgICAgICAgICAgICAgIG1hdGNoZWRQYXR0ZXJuQXJyYXlbMl0ucmVwbGFjZShuZXcgUmVnRXhwKFwiW1xcXFxcXFxcXFxcIl0oLilcIiwgXCJnXCIpLCAnJDEnKSA6IG1hdGNoZWRQYXR0ZXJuQXJyYXlbM107XHJcbiAgICAgICAgICAgIHJlc3VsdENTVltyZXN1bHRDU1YubGVuZ3RoIC0gMV0ucHVzaChjbGVhblZhbHVlKTtcclxuICAgICAgICAgICAgbWF0Y2hlZFBhdHRlcm5BcnJheSA9IHJlZ2V4UGF0dGVybi5leGVjKGNzdkRhdGFTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0Q1NWO1xyXG4gICAgfVxyXG5cclxuICAgIGdldERhdGFSZWNvcmRzQXJyYXlGcm9tQ1NWRmlsZShjc3ZSZWNvcmRzQXJyYXk6IGFueSwgaGVhZGVyTGVuZ3RoOiBhbnksIGNvbmZpZzogYW55KSB7XHJcbiAgICAgICAgY29uc3QgZGF0YUFyciA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnNBcnJheSA9IGNzdlJlY29yZHNBcnJheVswXTtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhcnRpbmdSb3dUb1BhcnNlRGF0YSA9IGNvbmZpZy5oZWFkZXIgPyAxIDogMDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0aW5nUm93VG9QYXJzZURhdGE7IGkgPCBjc3ZSZWNvcmRzQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNzdlJlY29yZHNBcnJheVtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gaGVhZGVyTGVuZ3RoICYmIGNvbmZpZy5oZWFkZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjc3ZSZWNvcmQgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGFbal0gPT09IHVuZGVmaW5lZCkgfHwgKGRhdGFbal0gPT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZFtoZWFkZXJzQXJyYXlbal1dID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3ZSZWNvcmRbaGVhZGVyc0FycmF5W2pdXSA9IGRhdGFbal0udHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRhdGFBcnIucHVzaChjc3ZSZWNvcmQpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YUFyci5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRhQXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGlzQ1NWRmlsZShmaWxlOiBhbnkpIHtcclxuICAgICAgICByZXR1cm4gZmlsZS5uYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoJy5jc3YnKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIZWFkZXJBcnJheShjc3ZSZWNvcmRzQXJyOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0gY3N2UmVjb3Jkc0FyclswXTtcclxuICAgICAgICBjb25zdCBoZWFkZXJBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIGhlYWRlcnMpIHtcclxuICAgICAgICAgICAgaGVhZGVyQXJyYXkucHVzaChoZWFkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGVhZGVyQXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgbm90Q1NWRmlsZUVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCdWlsZGVyKCdOT1RfQV9DU1ZfRklMRScsICdTZWxlY3RlZCBmaWxlIGlzIG5vdCBhIGNzdiBGaWxlIFR5cGUuJywgMik7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHVua25vd25DU1ZQYXJzZXJFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPVxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQnVpbGRlcignVU5LTk9XTl9FUlJPUicsICdVbmtub3duIGVycm9yLiBQbGVhc2UgcmVmZXIgdG8gb2ZmaWNpYWwgZG9jdW1lbnRhdGlvbiBmb3IgbGlicmFyeSB1c2FnZS4nLCA0MDQpO1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBiYWRDU1ZEYXRhRm9ybWF0RXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID1cclxuICAgICAgICAgICAgdGhpcy5lcnJvckJ1aWxkZXIoJ0JBRF9DU1ZfREFUQV9GT1JNQVQnLCAnVW5hYmxlIHRvIHBhcnNlIENTViBGaWxlLicsIDEpO1xyXG4gICAgICAgIG9ic2VydmVyLmVycm9yKG5nY0NTVlBhcnNlckVycm9yKTtcclxuICAgIH1cclxuXHJcbiAgICBlcnJvckJ1aWxkZXIodHlwZTogc3RyaW5nLCBtZXNzYWdlOiBhbnksIGNvZGU6IGFueSk6IE5neENTVlBhcnNlckVycm9yIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPSBuZXcgTmd4Q1NWUGFyc2VyRXJyb3IoKTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci50eXBlID0gdHlwZTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICBuZ2NDU1ZQYXJzZXJFcnJvci5jb2RlID0gY29kZTtcclxuICAgICAgICByZXR1cm4gbmdjQ1NWUGFyc2VyRXJyb3I7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNsYXNzIENTVlBhcnNlckNvbmZpZyB7XHJcbiAgICBoZWFkZXI/OiBib29sZWFuO1xyXG4gICAgZGVsaW1pdGVyPzogc3RyaW5nO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XHJcbn1cclxuIl19