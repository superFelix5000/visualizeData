import { __assign, __decorate, __values } from "tslib";
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { NgxCSVParserError } from './_model/ngx-csv-parser-error.interface';
import * as i0 from "@angular/core";
var NgxCsvParser = /** @class */ (function () {
    function NgxCsvParser() {
        this.defaultCSVParserConfig = {
            header: true,
            delimiter: ','
        };
    }
    NgxCsvParser.prototype.parse = function (csvFile, config) {
        var _this = this;
        config = __assign(__assign({}, this.defaultCSVParserConfig), config);
        var ngxCSVParserObserver = new Observable(function (observer) {
            try {
                var csvRecords_1 = null;
                if (_this.isCSVFile(csvFile)) {
                    var reader_1 = new FileReader();
                    reader_1.readAsText(csvFile);
                    reader_1.onload = function () {
                        var csvData = reader_1.result;
                        var csvRecordsArray = _this.csvStringToArray(csvData.trim(), config.delimiter);
                        var headersRow = _this.getHeaderArray(csvRecordsArray);
                        csvRecords_1 = _this.getDataRecordsArrayFromCSVFile(csvRecordsArray, headersRow.length, config);
                        observer.next(csvRecords_1);
                        observer.complete();
                    };
                    reader_1.onerror = function () {
                        _this.badCSVDataFormatErrorHandler(observer);
                    };
                }
                else {
                    _this.notCSVFileErrorHandler(observer);
                }
            }
            catch (error) {
                _this.unknownCSVParserErrorHandler(observer);
            }
        });
        return ngxCSVParserObserver;
    };
    NgxCsvParser.prototype.csvStringToArray = function (csvDataString, delimiter) {
        var regexPattern = new RegExp(("(\\" + delimiter + "|\\r?\\n|\\r|^)(?:\"((?:\\\\.|\"\"|[^\\\\\"])*)\"|([^\\" + delimiter + "\"\\r\\n]*))"), "gi");
        var matchedPatternArray = regexPattern.exec(csvDataString);
        var resultCSV = [[]];
        while (matchedPatternArray) {
            if (matchedPatternArray[1].length && matchedPatternArray[1] !== delimiter) {
                resultCSV.push([]);
            }
            var cleanValue = matchedPatternArray[2] ?
                matchedPatternArray[2].replace(new RegExp("[\\\\\"](.)", "g"), '$1') : matchedPatternArray[3];
            resultCSV[resultCSV.length - 1].push(cleanValue);
            matchedPatternArray = regexPattern.exec(csvDataString);
        }
        return resultCSV;
    };
    NgxCsvParser.prototype.getDataRecordsArrayFromCSVFile = function (csvRecordsArray, headerLength, config) {
        var dataArr = [];
        var headersArray = csvRecordsArray[0];
        var startingRowToParseData = config.header ? 1 : 0;
        for (var i = startingRowToParseData; i < csvRecordsArray.length; i++) {
            var data = csvRecordsArray[i];
            if (data.length === headerLength && config.header) {
                var csvRecord = {};
                for (var j = 0; j < data.length; j++) {
                    if ((data[j] === undefined) || (data[j] === null)) {
                        csvRecord[headersArray[j]] = "";
                    }
                    else {
                        csvRecord[headersArray[j]] = data[j].trim();
                    }
                }
                dataArr.push(csvRecord);
            }
            else {
                dataArr.push(data);
            }
        }
        return dataArr;
    };
    NgxCsvParser.prototype.isCSVFile = function (file) {
        return file.name.toLowerCase().endsWith('.csv');
    };
    NgxCsvParser.prototype.getHeaderArray = function (csvRecordsArr) {
        var e_1, _a;
        var headers = csvRecordsArr[0];
        var headerArray = [];
        try {
            for (var headers_1 = __values(headers), headers_1_1 = headers_1.next(); !headers_1_1.done; headers_1_1 = headers_1.next()) {
                var header = headers_1_1.value;
                headerArray.push(header);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (headers_1_1 && !headers_1_1.done && (_a = headers_1.return)) _a.call(headers_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return headerArray;
    };
    NgxCsvParser.prototype.notCSVFileErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('NOT_A_CSV_FILE', 'Selected file is not a csv File Type.', 2);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.unknownCSVParserErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('UNKNOWN_ERROR', 'Unknown error. Please refer to official documentation for library usage.', 404);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.badCSVDataFormatErrorHandler = function (observer) {
        var ngcCSVParserError = this.errorBuilder('BAD_CSV_DATA_FORMAT', 'Unable to parse CSV File.', 1);
        observer.error(ngcCSVParserError);
    };
    NgxCsvParser.prototype.errorBuilder = function (type, message, code) {
        var ngcCSVParserError = new NgxCSVParserError();
        ngcCSVParserError.type = type;
        ngcCSVParserError.message = message;
        ngcCSVParserError.code = code;
        return ngcCSVParserError;
    };
    NgxCsvParser.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxCsvParser_Factory() { return new NgxCsvParser(); }, token: NgxCsvParser, providedIn: "root" });
    NgxCsvParser = __decorate([
        Injectable({
            providedIn: 'root'
        })
    ], NgxCsvParser);
    return NgxCsvParser;
}());
export { NgxCsvParser };
var CSVParserConfig = /** @class */ (function () {
    function CSVParserConfig() {
    }
    return CSVParserConfig;
}());
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWNzdi1wYXJzZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1jc3YtcGFyc2VyLyIsInNvdXJjZXMiOlsibGliL25neC1jc3YtcGFyc2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLE1BQU0sQ0FBQztBQUM1QyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQzs7QUFLNUU7SUFBQTtRQUVZLDJCQUFzQixHQUFHO1lBQzdCLE1BQU0sRUFBRSxJQUFJO1lBQ1osU0FBUyxFQUFFLEdBQUc7U0FDakIsQ0FBQztLQWdJTDtJQTlIRyw0QkFBSyxHQUFMLFVBQU0sT0FBYSxFQUFFLE1BQXVCO1FBQTVDLGlCQTBDQztRQXhDRyxNQUFNLHlCQUNDLElBQUksQ0FBQyxzQkFBc0IsR0FDM0IsTUFBTSxDQUNaLENBQUM7UUFFRixJQUFNLG9CQUFvQixHQUFHLElBQUksVUFBVSxDQUFDLFVBQUMsUUFBa0Q7WUFDM0YsSUFBSTtnQkFDQSxJQUFJLFlBQVUsR0FBRyxJQUFJLENBQUM7Z0JBRXRCLElBQUksS0FBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFFekIsSUFBTSxRQUFNLEdBQUcsSUFBSSxVQUFVLEVBQUUsQ0FBQztvQkFDaEMsUUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztvQkFFM0IsUUFBTSxDQUFDLE1BQU0sR0FBRzt3QkFDWixJQUFNLE9BQU8sR0FBRyxRQUFNLENBQUMsTUFBTSxDQUFDO3dCQUM5QixJQUFNLGVBQWUsR0FBRyxLQUFJLENBQUMsZ0JBQWdCLENBQUUsT0FBa0IsQ0FBQyxJQUFJLEVBQUUsRUFBRSxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7d0JBRTVGLElBQU0sVUFBVSxHQUFHLEtBQUksQ0FBQyxjQUFjLENBQUMsZUFB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RCxJQUFNLGlCQUFpQixHQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSwwRUFBMEUsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4SCxRQUFRLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVELG1EQUE0QixHQUE1QixVQUE2QixRQUF1QjtRQUNoRCxJQUFNLGlCQUFpQixHQUNuQixJQUFJLENBQUMsWUFBWSxDQUFDLHFCQUFxQixFQUFFLDJCQUEyQixFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdFLFFBQVEsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQsbUNBQVksR0FBWixVQUFhLElBQVksRUFBRSxPQUFZLEVBQUUsSUFBUztRQUM5QyxJQUFNLGlCQUFpQixHQUFzQixJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDckUsaUJBQWlCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUM5QixpQkFBaUIsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1FBQ3BDLGlCQUFpQixDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDOUIsT0FBTyxpQkFBaUIsQ0FBQztJQUM3QixDQUFDOztJQXBJUSxZQUFZO1FBSHhCLFVBQVUsQ0FBQztZQUNSLFVBQVUsRUFBRSxNQUFNO1NBQ3JCLENBQUM7T0FDVyxZQUFZLENBcUl4Qjt1QkE1SUQ7Q0E0SUMsQUFySUQsSUFxSUM7U0FySVksWUFBWTtBQXVJekI7SUFJSTtJQUFnQixDQUFDO0lBQ3JCLHNCQUFDO0FBQUQsQ0FBQyxBQUxELElBS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmVyIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IE5neENTVlBhcnNlckVycm9yIH0gZnJvbSAnLi9fbW9kZWwvbmd4LWNzdi1wYXJzZXItZXJyb3IuaW50ZXJmYWNlJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICAgIHByb3ZpZGVkSW46ICdyb290J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4Q3N2UGFyc2VyIHtcclxuXHJcbiAgICBwcml2YXRlIGRlZmF1bHRDU1ZQYXJzZXJDb25maWcgPSB7XHJcbiAgICAgICAgaGVhZGVyOiB0cnVlLFxyXG4gICAgICAgIGRlbGltaXRlcjogJywnXHJcbiAgICB9O1xyXG5cclxuICAgIHBhcnNlKGNzdkZpbGU6IEZpbGUsIGNvbmZpZzogQ1NWUGFyc2VyQ29uZmlnKTogT2JzZXJ2YWJsZTxBcnJheTxhbnk+IHwgTmd4Q1NWUGFyc2VyRXJyb3I+IHtcclxuXHJcbiAgICAgICAgY29uZmlnID0ge1xyXG4gICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRDU1ZQYXJzZXJDb25maWcsXHJcbiAgICAgICAgICAgIC4uLmNvbmZpZ1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG5neENTVlBhcnNlck9ic2VydmVyID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyOiBPYnNlcnZlcjxBcnJheTxhbnk+IHwgTmd4Q1NWUGFyc2VyRXJyb3I+KSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3N2UmVjb3JkcyA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDU1ZGaWxlKGNzdkZpbGUpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoY3N2RmlsZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzdkRhdGEgPSByZWFkZXIucmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3ZSZWNvcmRzQXJyYXkgPSB0aGlzLmNzdlN0cmluZ1RvQXJyYXkoKGNzdkRhdGEgYXMgc3RyaW5nKS50cmltKCksIGNvbmZpZy5kZWxpbWl0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyc1JvdyA9IHRoaXMuZ2V0SGVhZGVyQXJyYXkoY3N2UmVjb3Jkc0FycmF5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZHMgPSB0aGlzLmdldERhdGFSZWNvcmRzQXJyYXlGcm9tQ1NWRmlsZShjc3ZSZWNvcmRzQXJyYXksIGhlYWRlcnNSb3cubGVuZ3RoLCBjb25maWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChjc3ZSZWNvcmRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWRDU1ZEYXRhRm9ybWF0RXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVua25vd25DU1ZQYXJzZXJFcnJvckhhbmRsZXIob2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBuZ3hDU1ZQYXJzZXJPYnNlcnZlcjtcclxuICAgIH1cclxuXHJcbiAgICBjc3ZTdHJpbmdUb0FycmF5KGNzdkRhdGFTdHJpbmc6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCByZWdleFBhdHRlcm4gPSBuZXcgUmVnRXhwKChgKFxcXFwke2RlbGltaXRlcn18XFxcXHI/XFxcXG58XFxcXHJ8XikoPzpcXFwiKCg/OlxcXFxcXFxcLnxcXFwiXFxcInxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChbXlxcXFwke2RlbGltaXRlcn1cXFwiXFxcXHJcXFxcbl0qKSlgKSwgXCJnaVwiKVxyXG4gICAgICAgIGxldCBtYXRjaGVkUGF0dGVybkFycmF5ID0gcmVnZXhQYXR0ZXJuLmV4ZWMoY3N2RGF0YVN0cmluZyk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0Q1NWID0gW1tdXTtcclxuICAgICAgICB3aGlsZSAobWF0Y2hlZFBhdHRlcm5BcnJheSkge1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hlZFBhdHRlcm5BcnJheVsxXS5sZW5ndGggJiYgbWF0Y2hlZFBhdHRlcm5BcnJheVsxXSAhPT0gZGVsaW1pdGVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRDU1YucHVzaChbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY2xlYW5WYWx1ZSA9IG1hdGNoZWRQYXR0ZXJuQXJyYXlbMl0gP1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFBhdHRlcm5BcnJheVsyXS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJbXFxcXFxcXFxcXFwiXSguKVwiLCBcImdcIiksICckMScpIDogbWF0Y2hlZFBhdHRlcm5BcnJheVszXTtcclxuICAgICAgICAgICAgcmVzdWx0Q1NWW3Jlc3VsdENTVi5sZW5ndGggLSAxXS5wdXNoKGNsZWFuVmFsdWUpO1xyXG4gICAgICAgICAgICBtYXRjaGVkUGF0dGVybkFycmF5ID0gcmVnZXhQYXR0ZXJuLmV4ZWMoY3N2RGF0YVN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRDU1Y7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0RGF0YVJlY29yZHNBcnJheUZyb21DU1ZGaWxlKGNzdlJlY29yZHNBcnJheTogYW55LCBoZWFkZXJMZW5ndGg6IGFueSwgY29uZmlnOiBhbnkpIHtcclxuICAgICAgICBjb25zdCBkYXRhQXJyID0gW107XHJcbiAgICAgICAgY29uc3QgaGVhZGVyc0FycmF5ID0gY3N2UmVjb3Jkc0FycmF5WzBdO1xyXG5cclxuICAgICAgICBjb25zdCBzdGFydGluZ1Jvd1RvUGFyc2VEYXRhID0gY29uZmlnLmhlYWRlciA/IDEgOiAwO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRpbmdSb3dUb1BhcnNlRGF0YTsgaSA8IGNzdlJlY29yZHNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY3N2UmVjb3Jkc0FycmF5W2ldO1xyXG5cclxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSBoZWFkZXJMZW5ndGggJiYgY29uZmlnLmhlYWRlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNzdlJlY29yZCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZGF0YS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YVtqXSA9PT0gdW5kZWZpbmVkKSB8fCAoZGF0YVtqXSA9PT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3N2UmVjb3JkW2hlYWRlcnNBcnJheVtqXV0gPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzdlJlY29yZFtoZWFkZXJzQXJyYXlbal1dID0gZGF0YVtqXS50cmltKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGF0YUFyci5wdXNoKGNzdlJlY29yZCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXRhQXJyLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRhdGFBcnI7XHJcbiAgICB9XHJcblxyXG4gICAgaXNDU1ZGaWxlKGZpbGU6IGFueSkge1xyXG4gICAgICAgIHJldHVybiBmaWxlLm5hbWUudG9Mb3dlckNhc2UoKS5lbmRzV2l0aCgnLmNzdicpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEhlYWRlckFycmF5KGNzdlJlY29yZHNBcnI6IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBjc3ZSZWNvcmRzQXJyWzBdO1xyXG4gICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xyXG4gICAgICAgICAgICBoZWFkZXJBcnJheS5wdXNoKGhlYWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoZWFkZXJBcnJheTtcclxuICAgIH1cclxuXHJcbiAgICBub3RDU1ZGaWxlRXJyb3JIYW5kbGVyKG9ic2VydmVyOiBPYnNlcnZlcjxhbnk+KSB7XHJcbiAgICAgICAgY29uc3QgbmdjQ1NWUGFyc2VyRXJyb3I6IE5neENTVlBhcnNlckVycm9yID1cclxuICAgICAgICAgICAgdGhpcy5lcnJvckJ1aWxkZXIoJ05PVF9BX0NTVl9GSUxFJywgJ1NlbGVjdGVkIGZpbGUgaXMgbm90IGEgY3N2IEZpbGUgVHlwZS4nLCAyKTtcclxuICAgICAgICBvYnNlcnZlci5lcnJvcihuZ2NDU1ZQYXJzZXJFcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAgdW5rbm93bkNTVlBhcnNlckVycm9ySGFuZGxlcihvYnNlcnZlcjogT2JzZXJ2ZXI8YW55Pikge1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JCdWlsZGVyKCdVTktOT1dOX0VSUk9SJywgJ1Vua25vd24gZXJyb3IuIFBsZWFzZSByZWZlciB0byBvZmZpY2lhbCBkb2N1bWVudGF0aW9uIGZvciBsaWJyYXJ5IHVzYWdlLicsIDQwNCk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGJhZENTVkRhdGFGb3JtYXRFcnJvckhhbmRsZXIob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pIHtcclxuICAgICAgICBjb25zdCBuZ2NDU1ZQYXJzZXJFcnJvcjogTmd4Q1NWUGFyc2VyRXJyb3IgPVxyXG4gICAgICAgICAgICB0aGlzLmVycm9yQnVpbGRlcignQkFEX0NTVl9EQVRBX0ZPUk1BVCcsICdVbmFibGUgdG8gcGFyc2UgQ1NWIEZpbGUuJywgMSk7XHJcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IobmdjQ1NWUGFyc2VyRXJyb3IpO1xyXG4gICAgfVxyXG5cclxuICAgIGVycm9yQnVpbGRlcih0eXBlOiBzdHJpbmcsIG1lc3NhZ2U6IGFueSwgY29kZTogYW55KTogTmd4Q1NWUGFyc2VyRXJyb3Ige1xyXG4gICAgICAgIGNvbnN0IG5nY0NTVlBhcnNlckVycm9yOiBOZ3hDU1ZQYXJzZXJFcnJvciA9IG5ldyBOZ3hDU1ZQYXJzZXJFcnJvcigpO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xyXG4gICAgICAgIG5nY0NTVlBhcnNlckVycm9yLmNvZGUgPSBjb2RlO1xyXG4gICAgICAgIHJldHVybiBuZ2NDU1ZQYXJzZXJFcnJvcjtcclxuICAgIH1cclxufVxyXG5cclxuY2xhc3MgQ1NWUGFyc2VyQ29uZmlnIHtcclxuICAgIGhlYWRlcj86IGJvb2xlYW47XHJcbiAgICBkZWxpbWl0ZXI/OiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7IH1cclxufVxyXG4iXX0=